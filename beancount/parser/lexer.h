// beancount/parser/lexer.h generated by reflex 2.1.5 from beancount/parser/lexer.l

#ifndef REFLEX_BEANCOUNT_PARSER_LEXER_H
#define REFLEX_BEANCOUNT_PARSER_LEXER_H
#define yyIN_HEADER 1
#define REFLEX_VERSION "2.1.5"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_bison_bridge        true
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_extra_type          yyextra_t*
#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_full                true
#define REFLEX_OPTION_header_file         "beancount/parser/lexer.h"
#define REFLEX_OPTION_lex                 yylex
#define REFLEX_OPTION_lexer               yyFlexLexer
#define REFLEX_OPTION_never_interactive   true
#define REFLEX_OPTION_nostdinit           true
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "beancount/parser/lexer.cpp"
#define REFLEX_OPTION_params              PyObject* builder
#define REFLEX_OPTION_prefix              yy
#define REFLEX_OPTION_reentrant           true
#define REFLEX_OPTION_unicode             true
#define REFLEX_OPTION_warn                true
#define REFLEX_OPTION_yylineno            true

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 31 "beancount/parser/lexer.l"


#include "beancount/parser/macros.h"
#include "beancount/parser/parser.h"
#include "beancount/parser/grammar.h"

#ifdef __cplusplus

#include <iostream>

class pyistream : private std::streambuf , public std::istream
{
public:
  pyistream(PyObject* in) : std::istream(this)
  {
    in_ = in;
    Py_INCREF(in_);
  }

  ~pyistream()
  {
    Py_XDECREF(in_);
  }

private:
  std::streamsize xsgetn(char* buf, std::streamsize n)
  {
    PyObject* dest = NULL;
    PyObject *read = NULL;
    size_t ret = 0;

    dest = PyMemoryView_FromMemory(buf, n, PyBUF_WRITE);
    if (!dest) {
      goto out;
    }

    read = PyObject_CallMethod(in_, "readinto", "O", dest);
    if (!read) {
      goto out;
    }

    ret = PyLong_AsSize_t(read);
    if (PyErr_Occurred()) {
	ret = 0;
    }

  out:
    Py_XDECREF(dest);
    Py_XDECREF(read);

    return ret;
  }

  PyObject* in_;
};

#endif

struct _yyextra_t {
    /* The filename being tokenized. */
    PyObject* filename;
    PyObject* in;

    /* The encoding to use for converting strings. */
    const char* encoding;
};

#define YY_EXTERN_C extern "C"

#define YY_USER_ACTION                          \
    {                                           \
        yylloc.file_name = yy_filename;         \
    }

typedef struct _yyextra_t yyextra_t;

C_BEGIN_DECLS

/**
 * Allocate a new scanner object including private data.
 *
 * This encapsulates the native yylex_init_extra() API.
 */
yyscan_t yylex_new(void);

/**
 * Free scanner object including private data.
 *
 * This encapsulated the native yylex_destroy() API. Python objects
 * references stored in the @scanner are decremented.
 */
yyscan_t yylex_free(yyscan_t scanner);

/**
 * Initialize scanner private data.
 *
 * Setup @scanner to read from the Python file-like object @file. Set
 * the reported file name to @filename, if not NULL and not None.
 * Otherwise try to obtain the file name from the @name attribute of
 * the @file object. If this fails, use the empty string. @encoding is
 * used to decode strings read from the input file, if not NULL,
 * otherwise the default UTF-8 encoding is used. Python objects
 * references are incremented. It is safe to call this multiple times.
 */
void yylex_initialize(PyObject* file, PyObject* filename, int lineno, const char* encoding, yyscan_t scanner);

size_t pyfile_read_into(PyObject *file, char *buf, size_t max_size);

C_END_DECLS



#ifdef __cplusplus

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE ABSTRACT LEXER CLASS                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/flexlexer.h>
typedef reflex::FlexLexer<reflex::Matcher> FlexLexer;

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class yyFlexLexer : public FlexLexer {
#line 20 "beancount/parser/lexer.l"

 public:
 std::istream* istream_;
 ~yyFlexLexer() { delete istream_; }

 public:
  yyFlexLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream        *os    = NULL)
    :
      FlexLexer(input, os)
  {
#line 26 "beancount/parser/lexer.l"

    istream_ = NULL;

  }
  virtual void yylloc_update(YYLTYPE& yylloc)
  {
    yylloc.first_line = static_cast<unsigned int>(matcher().lineno());
    yylloc.first_column = static_cast<unsigned int>(matcher().columno());
    yylloc.last_line = static_cast<unsigned int>(matcher().lineno_end());
    yylloc.last_column = static_cast<unsigned int>(matcher().columno_end());
  }
  virtual int yylex(void)
  {
    LexerError("yyFlexLexer::yylex invoked but %option bison-bridge and/or bison-locations is used");
    yyterminate();
  }
  virtual int yylex(YYSTYPE& yylval, YYLTYPE& yylloc, PyObject* builder);
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON BRIDGE LOCATIONS                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

typedef void *yyscan_t;
typedef yyFlexLexer yyscanner_t;

#ifndef YY_EXTERN_C
#define YY_EXTERN_C
#endif

#else // !__cplusplus

typedef void *yyscan_t;

#undef YY_EXTERN_C
#define YY_EXTERN_C

#ifndef yy_size_t
#define yy_size_t size_t
#endif

YY_EXTERN_C char *yyget_text(yyscan_t);
YY_EXTERN_C yy_size_t yyget_leng(yyscan_t);
YY_EXTERN_C int yyget_lineno(yyscan_t);
YY_EXTERN_C void yyset_lineno(int, yyscan_t);
YY_EXTERN_C FILE *yyget_in(yyscan_t);
YY_EXTERN_C void yyset_in(FILE*, yyscan_t);
YY_EXTERN_C int yyget_debug(yyscan_t);
YY_EXTERN_C void yyset_debug(int, yyscan_t);
YY_EXTERN_C yyextra_t* yyget_extra(yyscan_t);
YY_EXTERN_C void yyset_extra(yyextra_t*, yyscan_t);

#endif // __cplusplus

YY_EXTERN_C int yylex(YYSTYPE*, YYLTYPE*, yyscan_t, PyObject* builder);
YY_EXTERN_C void yylex_init(yyscan_t*);
YY_EXTERN_C void yylex_init_extra(yyextra_t*, yyscan_t*);
YY_EXTERN_C void yylex_destroy(yyscan_t);

#endif
